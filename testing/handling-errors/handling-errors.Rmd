---
title: "Handling Errors"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", error = TRUE, out.width = "100%")
library(learnr)
library(grader)
library(tidyverse)
tutorial_options(exercise.timelimit = 60, exercise.checker = grade_learnr)
```

## Conditions

Cautious programmers plan for the unexpected. In Python or Java, this is done by raising exceptions, but R draws on a different tradition. We say that the operation **signals** a **condition** that some other piece of code then **handles**. These things are all simpler to do using the rlang library, so we begin by loading that:

```{r}
library(rlang)
```

The three built-in kinds of conditions are, in order of increasing severity, **messages**, **warnings**, and **errors**. (There are also interrupts, which are generated by the user pressing Ctrl-C to stop an operation, but we will ignore those.) We can signal conditions of these three kinds using the functions `message`, `warning`, and `stop`, each of which takes an error message as a parameter.

```{r error=TRUE}
message("This is a message.")
warning("This is a warning.\n")
stop("This is an error.")
```

Note that we have to supply our own line ending for warnings. Note also that there are only a few situations in which a warning is appropriate: if something has truly gone wrong, we should stop, and if it hasn't, we should not distract users from more pressing concerns, like the odd shadows that seem to flicker in the corner of our eye as we examine the artifacts bequeathed to us by our late aunt.

FIXME: which of the following should the program stop for?

## Handling Conditions

The bluntest of instruments for handling conditions is to ignore them. If a statement is wrapped in `try`, conditions that are signalled in it are still reported, but execution continues. Compare this:

```{r}
attemptWithoutTry <- function(left, right){
  temp <- left + right
  "result" # returned
}
result <- attemptWithoutTry(1, "two")
cat("result is", result)
```

with this:

```{r}
attemptUsingTry <- function(left, right){
  temp <- try(left + right)
  "value returned" # returned
}
result <- attemptUsingTry(1, "two")
cat("result is", result)
```

If we are *sure* that we wish to incur the risk of silent failure, we can suppress the error messages from `try`:

```{r}
attemptUsingTryQuietly <- function(left, right){
  temp <- try(left + right, silent = TRUE)
  "result" # returned
}
result <- attemptUsingTryQuietly(1, "two")
cat("result is", result)
```

Do not do this, for it will, upon the day, leave your soul lost and gibbering in an incomprehensible silent hellscape.

FIXME: exercise.

## Handling Conditions

Should you wish to handle conditions rather than ignore them, you may invoke `tryCatch`. We begin by raising an error explicitly:

```{r}
tryCatch(
  stop("our message"),
  error = function(cnd) cat("error object is", as.character(cnd))
)
```

(We need to convert the error object `cnd` to character for printing because it is a list of two elements, the message and the call, but `cat` only handles character data.) Let's use this

```{r}
tryCatch(
  attemptWithoutTry(1, "two"),
  error = function(cnd) cat("error object is", as.character(cnd))
)
```

We can handle non-fatal errors using `withCallingHandlers`,
and define new types of conditions,
but this is done less often in day-to-day R code than in Python:
see *[Advanced R](http://adv-r.had.co.nz/)* for details.

FIXME: error handling exercises.
